ID	Area	Title	Description
24597	area-System.Net	HttpWebRequest Not Supported HTTP/1.0ï¼Ÿ	```  HttpRequest = (HttpWebRequest)WebRequest.CreateHttp(url);  HttpRequest.Method = method;  HttpRequest.ProtocolVersion = System.Net.HttpVersion.Version10;  ```  Parameter 1.0 is specified, but is not valid    Analysis of Using wireshark is still 1.1
24598	area-System.Diagnostics	System.Diagnostics.Tests.ProcessCollectionTests.TestThreadCollectionBehavior failed in CI	Failed test: System.Diagnostics.Tests.ProcessCollectionTests.TestThreadCollectionBehavior    Configuration:   osx10.12_debug    Detail: https://ci.dot.net/job/dotnet_corefx/job/master/job/osx10.12_debug/3296/testReport/System.Diagnostics.Tests/ProcessCollectionTests/TestThreadCollectionBehavior/    MESSAGE:  ~~~  System.IndexOutOfRangeException : Index was outside the bounds of the array.  ~~~    STACK TRACE:  ~~~  at System.Diagnostics.Tests.ProcessCollectionTests.TestThreadCollectionBehavior() in /Users/dotnet-bot/j/workspace/dotnet_corefx/master/osx10.12_debug/src/System.Diagnostics.Process/tests/ProcessCollectionTests.cs:line 95  ~~~  
24606	area-System.Memory	System.Memory package for netcoreapp2.0 is missing System.Numerics.Vectors reference	*Steps to Reproduce*:    1. docker run -it --rm microsoft/dotnet:2.0-sdk  2. mkdir ~/project  3. cd ~/project  4. dotnet new console  5. dotnet add package System.Memory --version 4.5.0-preview1-25812-01 --source https://dotnet.myget.org/F/dotnet-core/api/v3/index.json  6. `static void Main() { System.SpanExtensions.SequenceEqual(new byte[123], new byte[123]); }`  7. dotnet run    *Expected Behavior*:    No error.    *Actual Behavior*:    ```  Unhandled Exception: System.IO.FileLoadException: Could not load file or assembly 'System.Numerics.Vectors, Version=4.1.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)     at System.SpanHelpers.SequenceEqual(Byte& first, Byte& second, Int32 length)     at System.SpanExtensions.SequenceEqual(Span`1 first, ReadOnlySpan`1 second)     at project.Program.Main()  ```    *Workaround*:    8. dotnet add package System.Numerics.Vectors --version 4.5.0-preview1-25812-01 --source https://dotnet.myget.org/F/dotnet-core/api/v3/index.json  
24608	area-System.Data	sni.dll bug or problem using the same login.	I think there's a bug where I am using the same login to connect to a database, while another process is doing the same with connection pooling.   The way to test is to create a login for sql server, have 2 different apps connect using the same login under a service (using nssm as the service host). And the messasge sni.dll not found is sent on the connection open command.     The OS 2008 server sql server version 2008 r2.  
24610	area-System.Net	Is System.Net.Sockets a Implement Of NIO?	@anthonywanted commented on [Thu Oct 12 2017](https://github.com/dotnet/core/issues/1025)  # Issue Title    Is System.Net.Sockets an Implement Of NIO?    # General    Just few questions.  Is System.Net.Sockets an Implement of NIO?  In windows, is it an implement of IOCP?  In Linux, is it an implement of epoll?    How about aspnet core?    
24611	area-Serialization	Ignore the type in SGEN if it contains any property that only have private setter	Fix #19723    @shmao @zhenlan @mconnew 
24612	area-Infrastructure	Mark packages as stable for 2.0.3	cc: @weshaggard 
24616	area-System.IO	Switch WaitNamedPipe and CreateNamedPipeClient invocation ordering.	We need to do this as WaitNamedPipe is not supported in Windows Containers.  With this change, CreateNamedPipeClient will be called first, with call to WaitNamedPipe as  a fallback only. This will allow us to use NamedPipeClientStream inside Windows  Containers.    This should handle both https://github.com/dotnet/corefx/issues/24594 and https://github.com/dotnet/corefx/issues/22014.    Fixes #22014 per @jiria request keeping #24594 open until it is ported to the next servicing release.    [Edit: added last line to close one issue and make clear why the other one is still open]
24617	area-System.Memory	Proposal: {ReadOnly}Memory<T> Extensions (mirror Span)	## `{ReadOnly}Memory<T>` Extensions    ### Background    Came up in https://github.com/dotnet/corefx/pull/24389#discussion_r142536789    Currently you can use all the `Span<T>` extensions and methods from `Memory<T>` by extracting the `Span<T>` e.g.    ```csharp  memory0.Span.SequenceEqual(memory1.Span);  ```    However this has two downsides  1. Not discoverable; you need to use the Span property to find them  2. Span can't be used in an `async` method; so to use them you need to create a second method and call that    ### Proposal    Include the second method as extensions on `{ReadOnly}Memory<T>` that passes through to the Span    ```csharp  public static class MemoryExtensions  {      // Span methods converted to Memory extension      public static void CopyTo<T>(this Memory<T> memory, Memory<T> destination)          => memory.Span.CopyTo(destination.Span);      public static void CopyTo<T>(this ReadOnlyMemory<T> memory, Memory<T> destination)          => memory.Span.CopyTo(destination.Span);      public static bool TryCopyTo<T>(this Memory<T> memory, Memory<T> destination)          => memory.Span.TryCopyTo(destination.Span);      public static bool TryCopyTo<T>(this ReadOnlyMemory<T> memory, Memory<T> destination)          => memory.Span.TryCopyTo(destination.Span);      public static void Fill<T>(this Memory<T> memory, T value)          => memory.Span.Fill(value);        // Array extension as per Span extension      public static void CopyTo<T>(this T[] array, Memory<T> destination)          => array.CopyTo(destination.Span);        // Valid? via Owned memory?      public static ReadOnlyMemory<char> AsReadOnlyMemory(this string text);        // Discoverable conversions as per Span      public static Memory<T> AsMemory<T>(this ArraySegment<T> arraySegment) => arraySegment;      public static Memory<T> AsMemory<T>(this T[] array) => array;        // Span extension pass-throughs      public static int IndexOf(this Memory<byte> memory, byte value)          => memory.Span.IndexOf(value);      public static int IndexOf(this Memory<byte> memory, ReadOnlyMemory<byte> value)          => memory.Span.IndexOf(value.Span);      public static int IndexOf(this ReadOnlyMemory<byte> memory, byte value)          => memory.Span.IndexOf(value);      public static int IndexOf(this ReadOnlyMemory<byte> memory, ReadOnlyMemory<byte> value)          => memory.Span.IndexOf(value.Span);        public static int IndexOf<T>(this Memory<T> memory, T value)          where T : struct, IEquatable<T>          => memory.Span.IndexOf(value);      public static int IndexOf<T>(this Memory<T> memory, ReadOnlyMemory<T> value)          where T : struct, IEquatable<T>          => memory.Span.IndexOf(value.Span);      public static int IndexOf<T>(this ReadOnlyMemory<T> memory, T value)          where T : struct, IEquatable<T>          => memory.Span.IndexOf(value);      public static int IndexOf<T>(this ReadOnlyMemory<T> memory, ReadOnlyMemory<T> value)          where T : struct, IEquatable<T>          => memory.Span.IndexOf(value.Span);        public static int IndexOfAny(this Memory<byte> memory, byte value0, byte value1)          => memory.Span.IndexOfAny(value0, value1);      public static int IndexOfAny(this Memory<byte> memory, byte value0, byte value1, byte value2)          => memory.Span.IndexOfAny(value0, value1, value2);      public static int IndexOfAny(this Memory<byte> memory, ReadOnlyMemory<byte> values)          => memory.Span.IndexOfAny(values.Span);        public static int IndexOfAny(this ReadOnlyMemory<byte> memory, byte value0, byte value1)          => memory.Span.IndexOfAny(value0, value1);      public static int IndexOfAny(this ReadOnlyMemory<byte> memory, byte value0, byte value1, byte value2)          => memory.Span.IndexOfAny(value0, value1, value2);      public static int IndexOfAny(this ReadOnlyMemory<byte> memory, ReadOnlyMemory<byte> values)          => memory.Span.IndexOfAny(values.Span);        public static bool SequenceEqual(this Memory<byte> first, ReadOnlyMemory<byte> second)          => first.Span.SequenceEqual(second.Span);      public static bool SequenceEqual(this ReadOnlyMemory<byte> first, ReadOnlyMemory<byte> second)          => first.Span.SequenceEqual(second.Span);        public static bool SequenceEqual<T>(this Memory<T> first, ReadOnlyMemory<T> value)          where T : struct, IEquatable<T>          => first.Span.SequenceEqual(value.Span);      public static bool SequenceEqual<T>(this ReadOnlyMemory<T> first, ReadOnlyMemory<T> value)          where T : struct, IEquatable<T>          => first.Span.SequenceEqual(value.Span);        public static bool StartsWith(this Memory<byte> memory, ReadOnlyMemory<byte> value)          => memory.Span.StartsWith(value.Span);      public static bool StartsWith(this ReadOnlyMemory<byte> memory, ReadOnlyMemory<byte> value)          => memory.Span.StartsWith(value.Span);        public static bool StartsWith<T>(this Memory<T> memory, ReadOnlyMemory<T> value)          where T : struct, IEquatable<T>          => memory.Span.StartsWith(value.Span);      public static bool StartsWith<T>(this ReadOnlyMemory<T> memory, ReadOnlyMemory<T> value)          where T : struct, IEquatable<T>          => memory.Span.StartsWith(value.Span);  }  ```    ### Notes    Items that change length can't be replicated due to the backing store e,g, `AsBytes`, `NonPortableCast`    ### Question    Is a string conversion possible?  ```csharp      public static ReadOnlyMemory<char> AsReadOnlyMemory(this string text);  ```    /cc @davidfowl @KrzysztofCwalina @stephentoub @jkotas 
